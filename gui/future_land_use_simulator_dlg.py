# -*- coding: utf-8 -*-
"""
/***************************************************************************
 UrbanAreaDemandDialog
                                 A QGIS plugin
 Urban Area Demand
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-03-24
        git sha              : $Format:%H$
        copyright            : (C) 2023 by GALUP
        email                : chj.chen@ufl.edu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from pathlib import Path

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtWidgets import QProgressBar, QDialog
from qgis.gui import (
    QgisInterface,
    QgsFileWidget,
    QgsFilterLineEdit,
    QgsMessageBarItem,
)
from qgis.core import (
    QgsProject,
    QgsApplication,
    Qgis,
    QgsTask,
)
from qgis.PyQt.QtCore import Qt
from typing import Optional
import pandas as pd

from ..lib import config
from ..lib.maintask import FutureLandUseSimulatorTask

FORM_CLASS, _ = uic.loadUiType(
    str(
        Path(__file__).resolve().parent /
        "future_land_use_simulator_dlg_base.ui"
    )
)


class FutureLandUseSimulatorDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface: QgisInterface, parent=None):
        """Constructor."""
        super(FutureLandUseSimulatorDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.iface = iface

        self.progress_bar: Optional[QProgressBar] = None  # will be set in click_to_run()
        self.task: Optional[QgsTask] = None  # will be set in click_to_run()

        # create connection for OK and Cancel button
        self.tabWidget.setCurrentIndex(0)
        self.button_box.button(
            self.button_box.Ok
        ).setText("Run")  # change button text to Run default is Ok
        self.button_box.button(
            self.button_box.Cancel
        ).setText("Close")  # change button text to Close default is Cancel
        self.button_box.button(
            self.button_box.Ok
        ).clicked.connect(self.click_to_run)
        self.button_box.button(
            self.button_box.Cancel
        ).clicked.connect(self.close)

        # create dynamic connection with some buttons
        self.cb_region.currentTextChanged.connect(
            self.populate_district
        )
        self.cb_region.currentTextChanged.connect(
            self.disable_study_area
        )
        # cb_region, cb_district, and cb_year all trigger read_pop_project
        self.cb_district.currentTextChanged.connect(
            self.read_pop_project
        )
        self.cb_region.currentTextChanged.connect(
            self.read_pop_project
        )
        self.cb_year.currentTextChanged.connect(
            self.read_pop_project
        )
        self.cb_region.currentTextChanged.connect(
            self.pop_project_clean
        )
        self.cb_year.currentTextChanged.connect(
            self.pop_project_clean
        )
        self.file_area.fileChanged.connect(
            self.disable_populate_region
        )
        self.cb_year.currentTextChanged.connect(
            self.disable_yr
        )

    def populate_district(self):
        reg_name = self.cb_region.currentText()
        if reg_name == "N/A":
            self.cb_district.clear()
            self.cb_district.setEditable(False)
        elif reg_name == "Ahafo":
            self.cb_district.clear()
            self.cb_district.addItems(config.ahafo)
        elif reg_name == "Ashanti":
            self.cb_district.clear()
            self.cb_district.addItems(config.ashanti)
        elif reg_name == "Bono":
            self.cb_district.clear()
            self.cb_district.addItems(config.bono)
        elif reg_name == "Bono East":
            self.cb_district.clear()
            self.cb_district.addItems(config.bono_east)
        elif reg_name == "Central":
            self.cb_district.clear()
            self.cb_district.addItems(config.central)
        elif reg_name == "Eastern":
            self.cb_district.clear()
            self.cb_district.addItems(config.eastern)
        elif reg_name == "Greater Accra":
            self.cb_district.clear()
            self.cb_district.addItems(config.accra)
        elif reg_name == "North East":
            self.cb_district.clear()
            self.cb_district.addItems(config.ne)
        elif reg_name == "Northern":
            self.cb_district.clear()
            self.cb_district.addItems(config.north)
        elif reg_name == "Oti":
            self.cb_district.clear()
            self.cb_district.addItems(config.oti)
        elif reg_name == "Savannah":
            self.cb_district.clear()
            self.cb_district.addItems(config.sav)
        elif reg_name == "Upper East":
            self.cb_district.clear()
            self.cb_district.addItems(config.ue)
        elif reg_name == "Upper West":
            self.cb_district.clear()
            self.cb_district.addItems(config.uw)
        elif reg_name == "Volta":
            self.cb_district.clear()
            self.cb_district.addItems(config.volta)
        elif reg_name == "Western":
            self.cb_district.clear()
            self.cb_district.addItems(config.western)
        elif reg_name == "Western North":
            self.cb_district.clear()
            self.cb_district.addItems(config.west_north)
        else:
            self.cb_district.clear()

    def read_pop_project(self):
        yr = self.cb_year.currentText()
        region = self.cb_region.currentText()
        district = self.cb_district.currentText()

        csv_path = Path(__file__).parents[1] / "data/un_pop_projection.csv"
        pop_df = pd.read_csv(csv_path)

        if yr in config.yr_selectable and district:
            if district == "Entire Region":
                pop_project = pop_df.loc[
                    pop_df["reg_prop"] == region, f"{yr}_dif"
                ].sum()
            else:  # district specific
                pop_project = pop_df.loc[
                    pop_df["dist"] == district, f"{yr}_dif"
                ].values[0]
            self.le_proj_pop.setText(str(pop_project))

    def pop_project_clean(self):
        region = self.cb_region.currentText()
        yr_drop = self.cb_year.currentText()
        if yr_drop == "":
            self.le_proj_pop.clear()
        elif region == "N/A":
            self.le_proj_pop.clear()

    def disable_study_area(self):
        region = self.cb_region.currentText()
        if region == "N/A" or region == "":
            self.file_area.setEnabled(True)
        else:
            self.file_area.setFilePath("")
            self.file_area.setEnabled(False)

    def disable_populate_region(self):
        study_area = self.file_area.filePath()
        if study_area == "":
            self.cb_region.setEnabled(True)
        else:
            self.cb_region.setCurrentText("N/A")

    def disable_yr(self):
        yr_drop = self.cb_year.currentText()
        if yr_drop == "":
            self.le_year.setEnabled(True)
        else:
            self.le_year.clear()
            self.le_year.setEnabled(False)

    def click_to_run(self):
        # Create a progress bar in the QGIS message bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setMaximum(100)
        self.progress_bar.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        progress_msg: QgsMessageBarItem = (
            self.iface.messageBar().createMessage("Simulation Progress: ")
        )
        progress_msg.layout().addWidget(self.progress_bar)
        self.iface.messageBar().pushWidget(progress_msg, Qgis.Info)

        # create the task and connect its signals
        self.task = FutureLandUseSimulatorTask(
            "Executing Future Land Use Simulation",
            self.file_slopes,
            self.le_temp,
            self.file_lc,
            self.file_ag_suit,
            self.file_con_suit,
            self.file_urb_suit,
            self.cb_district,
            self.le_proj_pop,
            self.file_pop,
            self.cb_region,
            self.check_urb_ex,
            self.check_ag_ex,
            self.check_con_ex,
            self.check_herb_ex,
            self.check_urb_insuf,
            self.check_ag_insuf,
            self.check_con_insuf,
            self.check_herb_insuf,
            self.file_area,
            self.le_cxpb,
            self.le_mutpb,
            self.le_gen,
            self.le_init_pop,
            self.le_ag_low,
            self.le_ag_med,
            self.le_ag_high,
            self.le_con_low,
            self.le_con_med,
            self.le_con_high,
            self.le_urb_low,
            self.le_urb_med,
            self.le_urb_high,
            self.le_init_sample,
            self.le_out_field,
            self.output,
        )
        self.task.progressChanged.connect(self.progress_bar.setValue)
        self.task.taskCompleted.connect(self.iface.messageBar().clearWidgets)
        self.task.taskCompleted.connect(self.show)
        QgsApplication.taskManager().addTask(self.task)
        self.close()
